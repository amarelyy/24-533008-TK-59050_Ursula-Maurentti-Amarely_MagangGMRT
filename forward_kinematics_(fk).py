# -*- coding: utf-8 -*-
"""Forward Kinematics (FK)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PwM7yzfly3dRqTSbTKzyS4EKq2hQfJWT
"""

# Ursula Maurentti Amarely
# 24/533008/TK/59050

import math
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import os

L1 = 8.0   # Femur length in cm
L2 = 50.0   # Tibia length in cm
theta1_deg = 40.0 # Joint 1 angle (deg)
theta2_deg = 30.0 # Joint 2 angle (deg)

# The visualization output
OUT_DIR = "fk_outputs"
os.makedirs(OUT_DIR, exist_ok=True)
OUT_IMG_2D = os.path.join(OUT_DIR, "visualization_result.png")
OUT_IMG_3D = os.path.join(OUT_DIR, "visualization_result_3d.png")
OUT_EQUATION = os.path.join(OUT_DIR, "calc_fk.png")
OUT_SOLUTION = os.path.join(OUT_DIR, "fk_solution.txt")

def deg2rad(d): return d * math.pi / 180.0 # Convert to radian

# Homogenus Transformation Using the Denavit-Hartenberg Matrix
def homogeneous_transform(a, alpha, d, theta): # 4x4 matrix where a = link length, alpha = twist, d = offset, theta = joint angle
    return np.array([
        [ math.cos(theta), -math.sin(theta)*math.cos(alpha), math.sin(theta)*math.sin(alpha), a*math.cos(theta)],
        [ math.sin(theta), math.cos(theta)*math.cos(alpha),  -math.cos(theta)*math.sin(alpha), a*math.sin(theta)],
        [ 0,  math.sin(alpha), math.cos(alpha), d],
        [ 0,  0,  0,  1]
    ])

# Defining FK using Homogeneous Transformation Matrices
def fk_2dof_ht(l1, l2, th1_rad, th2_rad):
    # Transformation from base to joint 1. Rotation by theta1 around z-axis and translation by l1
    A1 = homogeneous_transform(l1, 0.0, 0.0, th1_rad)
    # Transformation from joint 1 to joint 2 or to the end effector. Rotation by theta2 and translation by l2
    A2 = homogeneous_transform(l2, 0.0, 0.0, th2_rad)
    # Get total transform using dot product
    T0_2 = A1.dot(A2)
    #Place x, y, z in their place inside T matrix
    x = T0_2[0, 3]
    y = T0_2[1, 3]
    z = T0_2[2, 3]
    return T0_2, (x, y, z)

# 2 DoF Formula
def fk_2dof_formula(l1, l2, th1_rad, th2_rad):
  # Compute the x abd y coordinate for the end effector
    x = l1 * math.cos(th1_rad) + l2 * math.cos(th1_rad + th2_rad)
    y = l1 * math.sin(th1_rad) + l2 * math.sin(th1_rad + th2_rad)
    return (x, y)

# Inverse Kinematics
def ik_2dof_analytic(l1, l2, x, y):
    r2 = x*x + y*y # Distance from orign to target point
    cos_t2 = (r2 - l1*l1 - l2*l2) / (2*l1*l2) # Find theta2
    if abs(cos_t2) > 1.0: # Since cosine only valid in the range of -1 to 1, make sure that it's not outside the range
        raise ValueError("Target not reachable.")
    t2_a = math.acos(cos_t2)   # For elbow bends down
    t2_b = -math.acos(cos_t2)  # For elbow bends up

    # IK formula for 2 DoF
    def t1_for(t2):
        k1 = l1 + l2*math.cos(t2)
        k2 = l2*math.sin(t2)
        return math.atan2(y, x) - math.atan2(k2, k1)
    return [(t1_for(t2_a), t2_a), (t1_for(t2_b), t2_b)] # Prints out the solution for both elbow-down and up

# Write the equation using LaTex
def save_equation_image(path):
    import matplotlib.pyplot as plt
    plt.figure(figsize=(6,4))
    plt.axis('off')
    plt.text(0, 0.95, "Forward Kinematics 2 DoF", fontsize=14, weight='bold')
    latex = (
        # FK
        r"$x = L_1 \cos\theta_1 + L_2 \cos(\theta_1+\theta_2)$" "\n"
        r"$y = L_1 \sin\theta_1 + L_2 \sin(\theta_1+\theta_2)$" "\n\n"
        # IK
        r"$\cos\theta_2 = \frac{x^2+y^2-L_1^2-L_2^2}{2 L_1 L_2}$" "\n"
        r"$\theta_2 = \pm \arccos(\cos\theta_2)$" "\n"
        r"$\theta_1 = \operatorname{atan2}(y,x) - \operatorname{atan2}(L_2\sin\theta_2, L_1 + L_2\cos\theta_2)$"
    )
    plt.text(0, 0.6, latex, fontsize=12, va='top')
    plt.savefig(path, bbox_inches='tight', dpi=200)
    plt.close()

# Plot 2D
def plot_2d(l1, l2, th1_rad, th2_rad, path):
    # Joint Position
    x1 = l1*math.cos(th1_rad); y1 = l1*math.sin(th1_rad) # Joint 1
    x2 = x1 + l2*math.cos(th1_rad + th2_rad); y2 = y1 + l2*math.sin(th1_rad + th2_rad) # End effector
    plt.figure(figsize=(7,7))
    plt.plot([0, x1, x2], [0, y1, y2], '-o', linewidth=3, markersize=8)
    plt.gca().set_aspect('equal', adjustable='box')

    # Autoscale or limits, making sure it fits inside the plot nicely
    limit = (l1 + l2) + max(l1, l2)*0.1
    plt.xlim(-limit, limit)
    plt.ylim(0, limit*1.1)
    plt.grid(True)
    plt.title(f"2 DoF FK (θ1={math.degrees(th1_rad):.1f}°, θ2={math.degrees(th2_rad):.1f}°)") # Adding labels
    plt.xlabel("X (cm)"); plt.ylabel("Y (cm)")
    plt.text(x2, y2 + 0.03*limit, f"({x2:.2f}, {y2:.2f}) cm", ha='center', color='black')
    plt.savefig(path, dpi=200)
    plt.close()

# Plot 3D (but plane still lies on the 2D)
def plot_3d(l1, l2, th1_rad, th2_rad, path):
    # Joint positions
    x1 = l1*math.cos(th1_rad); y1 = l1*math.sin(th1_rad) # First joint
    x2 = x1 + l2*math.cos(th1_rad + th2_rad); y2 = y1 + l2*math.sin(th1_rad + th2_rad) # End effector
    # Create the 3D Plot
    fig = plt.figure(figsize=(8,5))
    ax = fig.add_subplot(111, projection='3d')
    ax.plot([0, x1, x2], [0, y1, y2], [0, 0, 0], marker='o', linewidth=3) #
    # Define the axis limit
    limit = (l1 + l2) + max(l1, l2)*0.1
    ax.set_xlim(-limit, limit); ax.set_ylim(-limit, limit); ax.set_zlim(-limit*0.1, limit*0.1)
    ax.set_xlabel('X (cm)'); ax.set_ylabel('Y (cm)'); ax.set_zlabel('Z (cm)') # Label
    ax.set_title('3D view')
    plt.savefig(path, dpi=200)
    plt.close()

# Main function
def main():
    # Convert to rad
    th1 = deg2rad(theta1_deg)
    th2 = deg2rad(theta2_deg)

    # FK using Trigonometric Formula
    x_f, y_f = fk_2dof_formula(L1, L2, th1, th2)
    # FK using Homogenus Transformation
    T0_2, pos_ht = fk_2dof_ht(L1, L2, th1, th2)

    # IK
    try:
        ik_sols = ik_2dof_analytic(L1, L2, x_f, y_f)
    except Exception as e:
        ik_sols = f"IK error: {e}"

    # Save the summary of result in a text file
    with open(OUT_SOLUTION, "w") as f:
        f.write("Forward Kinematics 2 DoF\n")
        f.write(f"L1 = {L1} cm, L2 = {L2} cm\n")
        f.write(f"Theta1 = {theta1_deg} deg, Theta2 = {theta2_deg} deg\n")
        f.write(f"FK (formula) => x = {x_f:.6f} cm, y = {y_f:.6f} cm\n")
        f.write("FK (HT matrix) => position = {}\n".format(pos_ht))
        f.write("IK solutions (rad) => {}\n".format(ik_sols))

    # Save the image and plot
    save_equation_image(OUT_EQUATION)
    plot_2d(L1, L2, th1, th2, OUT_IMG_2D)
    plot_3d(L1, L2, th1, th2, OUT_IMG_3D)

    # Showing the summary result in terminal
    print("FK result (x,y):", x_f, y_f)
    print("HT matrix T0_2:\n", T0_2)
    print("IK solutions (rad):", ik_sols)
    print("Saved files in", OUT_DIR)

# Run the program
if __name__ == "__main__":
    main()